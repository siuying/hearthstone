/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/version"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    Opal.cdecl($scope, 'VERSION', "0.3.0")
  })(self)
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/parser"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_accessor', '$===', '$to_i', '$parse_power_tag_change_entity', '$parse_power_tag_change', '$parse_zone', '$private', '$==', '$debug', '$raise', '$%', '$>', '$=~', '$parse_zone_to_secret', '$parse_zone_to_hand', '$parse_zone_to_deck', '$parse_zone_to_play', '$parse_zone_to_graveyard', '$parse_zone_to_setaside']);
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $Parser(){};
        var self = $Parser = $klass($base, $super, 'Parser', $Parser);

        var def = self.$$proto, $scope = self.$$scope;

        self.$attr_accessor("debug");

        def.$initialize = function() {
          var self = this;

          return self.debug = false;
        };

        def.$parse_line = function(line) {
          var $a, self = this, $case = nil, mode = nil, id = nil, card = nil, card_id = nil, player = nil, type = nil, amount = nil, state = nil, from_id = nil, from_card_id = nil, from_player = nil, to_id = nil, to_card_id = nil, to_player = nil, name = nil, zone_id = nil, local = nil, card_zone = nil, zone_pos = nil, from_zone = nil, to_zone = nil;

          return (function() {$case = line;if (/^Initialize engine version/['$===']($case)) {return ["startup"]}else if (/\[Power\] .* Begin Spectating/['$===']($case)) {return ["begin_spectator_mode"]}else if (/\[Power\] .* End Spectator Mode/['$===']($case)) {return ["end_spectator_mode"]}else if (/\[LoadingScreen\] LoadingScreen.OnSceneLoaded\(\) - prevMode=.* currMode=(.*)/['$===']($case)) {mode = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          return (function() {$case = mode;if ("DRAFT"['$===']($case)) {return ["mode", "arena"]}else if ("TOURNAMENT"['$===']($case)) {return ["mode", "ranked"]}else if ("ADVENTURE"['$===']($case)) {return ["mode", "solo"]}else { return nil }})();}else if (/\[Power\] GameState.DebugPrintPower\(\) -\s*FULL_ENTITY.*Creating ID=(\d*) CardID=(?!GAME)(.+)/['$===']($case)) {id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i();
          card = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          return ["open_card", $hash2(["id", "card_id"], {"id": id, "card_id": card})];}else if (/\[Power\] GameState.DebugPrintPower\(\) -\s*TAG_CHANGE Entity=\[.*id=(\d*).* cardId=(.*?) .* ?player=(\d)\] tag=(.*) value=(.*)/['$===']($case)) {id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i();
          card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$to_i();
          type = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4));
          amount = (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)).$to_i();
          return self.$parse_power_tag_change_entity(type, id, card_id, player, amount);}else if (/\[Power\] GameState.DebugPrintPower\(\) -\s*TAG_CHANGE Entity=(.*) tag=(.*) value=(.*)/['$===']($case)) {player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          type = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          state = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
          return self.$parse_power_tag_change(type, player, state);}else if (/\[Power\] GameState.SendChoices\(\) - id=(\d*) ChoiceType=(.*)/['$===']($case)) {return ["choice_type", (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))]}else if (/\[Power\] GameState.DebugPrintPower\(\) - ACTION_START Entity=\[name=.* id=(\d*) .* cardId=(.*) player=(\d)\] SubType=ATTACK .* Target=\[name=.* id=(\d*) .* cardId=(.*) player=(\d)\]/['$===']($case)) {from_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i();
          from_card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          from_player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$to_i();
          to_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4)).$to_i();
          to_card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](5));
          to_player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](6)).$to_i();
          return ["action_start", $hash2(["subtype", "from", "to"], {"subtype": "ATTACK", "from": $hash2(["id", "card_id", "player_id"], {"id": from_id, "card_id": from_card_id, "player_id": from_player}), "to": $hash2(["id", "card_id", "player_id"], {"id": to_id, "card_id": to_card_id, "player_id": to_player})})];}else if (/\[Power\] GameState.SendChoices\(\) -\s*m_chosenEntities\[0\]=\[name=(.*) id=(\d*) zone=(SETASIDE|HAND).*cardId=(.*) player=(\d)\]/['$===']($case)) {name = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$to_i();
          card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4));
          player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)).$to_i();
          return ["choose", $hash2(["id", "card_id", "player_id"], {"id": id, "card_id": card_id, "player_id": player})];}else if (/\[Power\] GameState.DebugPrintPower\(\).*TAG_CHANGE Entity=\[name=.* id=.* zone=PLAY zonePos=0 cardId=(.*) player=(\d)\] tag=EXHAUSTED value=1/['$===']($case)) {card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$to_i();
          return ["hero_power", $hash2(["card_id", "player_id"], {"card_id": card_id, "player_id": player})];}else if (/\[Zone\] ZoneChangeList\.ProcessChanges\(\) - id=(\d*) local=(.*) \[name=(.*) id=(\d*) zone=(.*) zonePos=(\d*) cardId=(.*) player=(\d*)\] zone from (.*) -> (.*)/['$===']($case)) {zone_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          local = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          card = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
          id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4));
          card_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](5));
          zone_pos = (($a = $gvars['~']) === nil ? nil : $a['$[]'](6));
          card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](7));
          player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](8));
          from_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](9));
          to_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](10));
          return self.$parse_zone(card_zone, from_zone, to_zone, zone_pos.$to_i(), card, card_id, player.$to_i(), id.$to_i());}else if (/\[Zone\] ZoneChangeList\.ProcessChanges\(\) - id=(\d*) local=(.*) \[id=(\d*) cardId=(.*) type=(.*) zone=(.*) zonePos=(\d*) player=(\d*)\] zone from (.*) -> (.*)/['$===']($case)) {zone_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
          local = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
          card_id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4));
          card_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](6));
          zone_pos = (($a = $gvars['~']) === nil ? nil : $a['$[]'](7));
          player = (($a = $gvars['~']) === nil ? nil : $a['$[]'](8));
          from_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](9));
          to_zone = (($a = $gvars['~']) === nil ? nil : $a['$[]'](10));
          return self.$parse_zone(card_zone, from_zone, to_zone, zone_pos.$to_i(), "", card_id, player.$to_i(), id.$to_i());}else { return nil }})();
        };

        self.$private();

        def.$parse_power_tag_change = function(type, player, state) {
          var $a, $b, self = this, $case = nil;

          return (function() {$case = type;if ("PLAYER_ID"['$===']($case)) {return ["player_id", $hash2(["name", "player_id"], {"name": player, "player_id": state.$to_i()})]}else if ("FIRST_PLAYER"['$===']($case)) {return ["first_player", $hash2(["name"], {"name": player})]}else if ("PLAYSTATE"['$===']($case)) {if ((($a = ((($b = state['$==']("WON")) !== false && $b !== nil) ? $b : state['$==']("LOST"))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["game_over", $hash2(["name", "state"], {"name": player, "state": state})]
            } else {
            return nil
          }}else if ("TURN_START"['$===']($case)) {if (player['$==']("GameEntity")) {
            return ["game_start"]
            } else {
            return ["turn_start", $hash2(["name", "timestamp"], {"name": player, "timestamp": state.$to_i()})]
          }}else if ("TURN"['$===']($case)) {return ["turn", state.$to_i()]}else if ("ATTACHED"['$===']($case)) {return ["attached", $hash2(["id", "target"], {"id": player.$to_i(), "target": state.$to_i()})]}else {if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unknown entity: %s, %s, %s"['$%']([type, player, state]))
            } else {
            return nil
          }}})();
        };

        def.$parse_power_tag_change_entity = function(type, id, card_id, player, amount) {
          var $a, self = this, $case = nil;

          return (function() {$case = type;if ("DAMAGE"['$===']($case)) {if (amount['$>'](0)) {
            return ["damaged", $hash2(["id", "card_id", "player_id", "amount"], {"id": id, "card_id": card_id, "player_id": player, "amount": amount})]
            } else {
            return nil
          }}else if ("ATTACKING"['$===']($case)) {if (amount['$=='](1)) {
            return ["attack", $hash2(["id", "card_id", "player_id"], {"id": id, "card_id": card_id, "player_id": player})]
            } else {
            return nil
          }}else if ("DEFENDING"['$===']($case)) {if (amount['$=='](1)) {
            return ["attacked", $hash2(["id", "card_id", "player_id"], {"id": id, "card_id": card_id, "player_id": player})]
            } else {
            return nil
          }}else if ("CARD_TARGET"['$===']($case)) {return ["card_target", $hash2(["id", "card_id", "player_id", "target"], {"id": id, "card_id": card_id, "player_id": player, "target": amount})]}else {if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unknown entity: %s, %s, %s, %s, %s"['$%']([type, id, card_id, player, amount]))
            } else {
            return nil
          }}})();
        };

        def.$parse_zone = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, self = this;

          if ((($a = ((($b = to_zone['$=~'](/SECRET/)) !== false && $b !== nil) ? $b : from_zone['$=~'](/SECRET/))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$parse_zone_to_secret(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if ((($a = to_zone['$=~'](/HAND/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$parse_zone_to_hand(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if ((($a = to_zone['$=~'](/DECK/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$parse_zone_to_deck(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if ((($a = ((($b = to_zone['$=~'](/PLAY/)) !== false && $b !== nil) ? $b : from_zone['$=~'](/HAND/))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$parse_zone_to_play(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if ((($a = to_zone['$=~'](/GRAVEYARD/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$parse_zone_to_graveyard(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if (to_zone['$==']("")) {
            return self.$parse_zone_to_setaside(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id)};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported play: %s, %s, %s, %s, %s %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        def.$parse_zone_to_hand = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, $c, self = this;

          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING DECK")) ? to_zone['$==']("OPPOSING HAND") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY DECK")) ? to_zone['$==']("FRIENDLY HAND") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_drawn", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = ((($c = from_zone['$==']("")) ? to_zone['$==']("OPPOSING HAND") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("")) ? to_zone['$==']("FRIENDLY HAND") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_received", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = ((($c = from_zone['$==']("FRIENDLY PLAY")) ? to_zone['$==']("FRIENDLY HAND") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("OPPOSING PLAY")) ? to_zone['$==']("OPPOSING HAND") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_returned", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported hand: %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        def.$parse_zone_to_play = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, $c, self = this;

          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING HAND")) ? to_zone['$==']("") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY HAND")) ? to_zone['$==']("") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_played", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING HAND")) ? to_zone['$==']("OPPOSING PLAY") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY HAND")) ? to_zone['$==']("FRIENDLY PLAY") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_played", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING DECK")) ? to_zone['$==']("OPPOSING PLAY") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY DECK")) ? to_zone['$==']("FRIENDLY PLAY") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_played", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = (($b = from_zone['$==']("")) ? to_zone['$=~'](/PLAY \(Hero\)/) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["set_hero", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = (($b = from_zone['$==']("")) ? to_zone['$=~'](/PLAY \(Hero Power\)/) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["set_hero_power", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = (($b = from_zone['$==']("")) ? to_zone['$=~'](/PLAY/) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_put_in_play", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported play: %s, %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        def.$parse_zone_to_deck = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, $c, self = this;

          if ((($a = ((($b = ((($c = from_zone['$==']("FRIENDLY HAND")) ? to_zone['$==']("FRIENDLY DECK") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("OPPOSING HAND")) ? to_zone['$==']("OPPOSING DECK") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_reshuffled", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = (($b = from_zone['$==']("")) ? (to_zone['$=~'](/DECK/)) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_added_to_deck", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported deck: %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        def.$parse_zone_to_graveyard = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, self = this;

          if ((($a = ((($b = from_zone['$==']("")) !== false && $b !== nil) ? $b : from_zone['$=~'](/HAND/))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_discarded", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = from_zone['$=~'](/DECK/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_discarded_from_deck", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = from_zone['$=~'](/PLAY \(Hero\)/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["hero_destroyed", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = from_zone['$=~'](/PLAY/)) !== false && $b !== nil) ? $b : from_zone['$=~'](/SECRET/))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_destroyed", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported gy: %s, %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        def.$parse_zone_to_secret = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, $b, $c, self = this;

          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING HAND")) ? to_zone['$==']("OPPOSING SECRET") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY HAND")) ? to_zone['$==']("FRIENDLY SECRET") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_played", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ((($b = ((($c = from_zone['$==']("OPPOSING DECK")) ? to_zone['$==']("OPPOSING SECRET") : $c))) !== false && $b !== nil) ? $b : ((($c = from_zone['$==']("FRIENDLY DECK")) ? to_zone['$==']("FRIENDLY SECRET") : $c)))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_put_in_play", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = ($b = from_zone['$=~'](/SECRET/), $b !== false && $b !== nil ?to_zone['$==']("") : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_revealed", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported secret: %s, %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        };

        return (def.$parse_zone_to_setaside = function(card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id) {
          var $a, self = this;

          if ((($a = from_zone['$=~'](/PLAY/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_setaside", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = from_zone['$=~'](/DECK/)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ["card_setaside", $hash2(["player_id", "id", "card_id", "zone_pos"], {"player_id": player, "id": id, "card_id": card_id, "zone_pos": zone_pos})]};
          if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise("unsupported setaside: %s, %s, %s, %s, %s, %s, %s"['$%']([card_zone, from_zone, to_zone, zone_pos, card, card_id, player, id]))
            } else {
            return nil
          };
        }, nil) && 'parse_zone_to_setaside';
      })(self, null)
    })(self)
  })(self)
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/data/game_turn"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$push', '$number', '$player', '$timestamp', '$events']);
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $GameTurn(){};
        var self = $GameTurn = $klass($base, $super, 'GameTurn', $GameTurn);

        var def = self.$$proto, $scope = self.$$scope;

        def.events = nil;
        self.$attr_accessor("number", "player", "timestamp");

        self.$attr_reader("events");

        def.$initialize = function($kwargs) {
          var self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((number = $kwargs.smap['number']) == null) {
            number = nil
          }
          if ((player = $kwargs.smap['player']) == null) {
            player = nil
          }
          if ((timestamp = $kwargs.smap['timestamp']) == null) {
            timestamp = nil
          }
          self.events = [];
          self.number = number;
          self.player = player;
          return self.timestamp = timestamp;
        };

        def.$add_event = function(event, data, line) {
          var self = this;

          if (line == null) {
            line = nil
          }
          if (line !== false && line !== nil) {
            return self.events.$push([event, data, line])
            } else {
            return self.events.$push([event, data])
          };
        };

        return (def.$to_hash = function() {
          var self = this;

          return $hash2(["number", "player", "timestamp", "events"], {"number": self.$number(), "player": self.$player(), "timestamp": self.$timestamp(), "events": self.$events()});
        }, nil) && 'to_hash';
      })(self, null)
    })(self)
  })(self)
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/data/game_player"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_accessor', '$id', '$name', '$first_player', '$hero', '$hero_power']);
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $GamePlayer(){};
        var self = $GamePlayer = $klass($base, $super, 'GamePlayer', $GamePlayer);

        var def = self.$$proto, $scope = self.$$scope;

        self.$attr_accessor("id", "name", "first_player");

        self.$attr_accessor("hero", "hero_power");

        def.$initialize = function($kwargs) {
          var self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((id = $kwargs.smap['id']) == null) {
            id = nil
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          self.name = name;
          self.id = id;
          return self.first_player = false;
        };

        return (def.$to_hash = function() {
          var self = this;

          return $hash2(["id", "name", "first_player", "hero", "hero_power"], {"id": self.$id(), "name": self.$name(), "first_player": self.$first_player(), "hero": self.$hero(), "hero_power": self.$hero_power()});
        }, nil) && 'to_hash';
      })(self, null)
    })(self)
  })(self)
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["json"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $klass = Opal.klass;

  Opal.add_stubs(['$new', '$push', '$[]=', '$[]', '$create_id', '$json_create', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  (function($base) {
    var self = $module($base, 'JSON');

    var def = self.$$proto, $scope = self.$$scope, $a, $b;

    
    var $parse  = JSON.parse,
        $hasOwn = Opal.hasOwnProperty;

    function to_opal(value, options) {
      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            var arr = (options.array_class).$new();

            for (var i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            var hash = (options.object_class).$new();

            for (var k in value) {
              if ($hasOwn.call(value, k)) {
                (hash)['$[]='](k, to_opal(value[k], options));
              }
            }

            var klass;
            if ((klass = (hash)['$[]']($scope.get('JSON').$create_id())) != nil) {
              klass = Opal.cget(klass);
              return (klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
      }
    };
  

    (function(self) {
      var $scope = self.$$scope, def = self.$$proto;

      return self.$attr_accessor("create_id")
    })(self.$singleton_class());

    (($a = ["json_class"]), $b = self, $b['$create_id='].apply($b, $a), $a[$a.length-1]);

    Opal.defs(self, '$[]', function(value, options) {
      var $a, self = this;

      if (options == null) {
        options = $hash2([], {})
      }
      if ((($a = $scope.get('String')['$==='](value)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return self.$parse(value, options)
        } else {
        return self.$generate(value, options)
      };
    });

    Opal.defs(self, '$parse', function(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {})
      }
      return self.$from_object($parse(source), options);
    });

    Opal.defs(self, '$parse!', function(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {})
      }
      return self.$parse(source, options);
    });

    Opal.defs(self, '$from_object', function(js_object, options) {
      var $a, $b, $c, self = this;

      if (options == null) {
        options = $hash2([], {})
      }
      ($a = "object_class", $b = options, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, $scope.get('Hash'))));
      ($a = "array_class", $b = options, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, $scope.get('Array'))));
      return to_opal(js_object, options.smap);
    });

    Opal.defs(self, '$generate', function(obj, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {})
      }
      return obj.$to_json(options);
    });

    Opal.defs(self, '$dump', function(obj, io, limit) {
      var $a, self = this, string = nil;

      if (io == null) {
        io = nil
      }
      if (limit == null) {
        limit = nil
      }
      string = self.$generate(obj);
      if (io !== false && io !== nil) {
        if ((($a = io['$responds_to?']("to_io")) !== nil && (!$a.$$is_boolean || $a == true))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
        } else {
        return string
      };
    });
  })(self);
  (function($base, $super) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $scope = self.$$scope;

    return (Opal.defn(self, '$to_json', function() {
      var self = this;

      return self.$to_s().$to_json();
    }), nil) && 'to_json'
  })(self, null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    var def = self.$$proto, $scope = self.$$scope;

    Opal.defn(self, '$to_json', function() {
      var self = this;

      return self.$to_a().$to_json();
    })
  })(self);
  (function($base, $super) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, nil) && 'to_json'
  })(self, null);
  (function($base, $super) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, nil) && 'to_json'
  })(self, null);
  (function($base, $super) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      
      var inspect = [],
          keys = self.keys,
          _map = self.map,
          smap = self.smap,
          map, khash;

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];

        if (key.$$is_string) {
          map = smap;
          khash = key;
        } else {
          map = _map;
          khash = key.$hash();
        }

        inspect.push((key).$to_s().$to_json() + ':' + (map[khash]).$to_json());
      }

      return '{' + inspect.join(', ') + '}';
    ;
    }, nil) && 'to_json'
  })(self, null);
  (function($base, $super) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      return "null";
    }, nil) && 'to_json'
  })(self, null);
  (function($base, $super) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      return self.toString();
    }, nil) && 'to_json'
  })(self, null);
  (function($base, $super) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $scope = self.$$scope;

    return Opal.defn(self, '$to_json', def.$inspect)
  })(self, null);
  (function($base, $super) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.$$proto, $scope = self.$$scope;

    return (def.$to_json = function() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json();
    }, nil) && 'to_json'
  })(self, null);
  return (function($base, $super) {
    function $Date(){};
    var self = $Date = $klass($base, $super, 'Date', $Date);

    var def = self.$$proto, $scope = self.$$scope;

    def.$to_json = function() {
      var self = this;

      return self.$to_s().$to_json();
    };

    return (def.$as_json = function() {
      var self = this;

      return self.$to_s();
    }, nil) && 'as_json';
  })(self, null);
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/data/game"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$attr_accessor', '$attr_reader', '$add_turn', '$<<', '$new', '$==', '$%', '$detect', '$first_player', '$players', '$name=', '$last', '$id', '$name', '$count', '$results', '$collect', '$to_proc', '$turns', '$mode', '$pretty_generate', '$to_hash', '$timestamp', '$!', '$to_i', '$now', '$strftime', '$at', '$first']);
  self.$require("hearthstone/log/data/game"+ '/../' + "./game_turn");
  self.$require("hearthstone/log/data/game"+ '/../' + "./game_player");
  self.$require("json");
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $Game(){};
        var self = $Game = $klass($base, $super, 'Game', $Game);

        var def = self.$$proto, $scope = self.$$scope;

        def.turns = nil;
        self.$attr_accessor("mode");

        self.$attr_reader("turns", "players", "results");

        def.$initialize = function(mode) {
          var self = this;

          self.mode = mode;
          self.results = $hash2([], {});
          self.players = [];
          self.turns = [];
          return self.$add_turn($hash2(["number", "player", "timestamp"], {"number": 0, "player": nil, "timestamp": nil}));
        };

        def.$add_turn = function($kwargs) {
          var $a, $b, TMP_1, $c, self = this, is_first_player = nil, the_player = nil;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((number = $kwargs.smap['number']) == null) {
            number = nil
          }
          if ((player = $kwargs.smap['player']) == null) {
            player = nil
          }
          if ((timestamp = $kwargs.smap['timestamp']) == null) {
            timestamp = nil
          }
          self.turns['$<<']($scope.get('GameTurn').$new($hash2(["number", "player", "timestamp"], {"number": number, "player": player, "timestamp": timestamp})));
          if ((($a = (($b = player !== false && player !== nil) ? number : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
            is_first_player = (number['$%'](2)['$=='](1));
            the_player = ($a = ($b = self.$players()).$detect, $a.$$p = (TMP_1 = function(p){var self = TMP_1.$$s || this;
if (p == null) p = nil;
            return p.$first_player()['$=='](is_first_player)}, TMP_1.$$s = self, TMP_1), $a).call($b);
            if (the_player !== false && the_player !== nil) {
              return (($a = [player]), $c = the_player, $c['$name='].apply($c, $a), $a[$a.length-1])
              } else {
              return nil
            };
            } else {
            return nil
          };
        };

        def.$current_turn = function() {
          var self = this;

          return self.turns.$last();
        };

        def.$player_with_id_or_name = function($kwargs) {
          var $a, $b, TMP_2, self = this, player = nil;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((id = $kwargs.smap['id']) == null) {
            id = nil
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          player = ($a = ($b = self.$players()).$detect, $a.$$p = (TMP_2 = function(p){var self = TMP_2.$$s || this, $a, $b;
if (p == null) p = nil;
          return ((($a = ((($b = id !== false && id !== nil) ? p.$id()['$=='](id) : $b))) !== false && $a !== nil) ? $a : ((($b = name !== false && name !== nil) ? p.$name()['$=='](name) : $b)))}, TMP_2.$$s = self, TMP_2), $a).call($b);
          if (player !== false && player !== nil) {
            } else {
            player = $scope.get('GamePlayer').$new($hash2(["name", "id"], {"name": name, "id": id}));
            self.$players()['$<<'](player);
          };
          return player;
        };

        def['$completed?'] = function() {
          var self = this;

          return self.$results().$count()['$=='](2);
        };

        def.$to_hash = function() {
          var $a, $b, $c, self = this, players_hash = nil, turns_hash = nil;

          players_hash = ($a = ($b = self.$players()).$collect, $a.$$p = "to_hash".$to_proc(), $a).call($b);
          turns_hash = ($a = ($c = self.$turns()).$collect, $a.$$p = "to_hash".$to_proc(), $a).call($c);
          return $hash2(["mode", "players", "turns", "results"], {"mode": self.$mode(), "players": players_hash, "turns": turns_hash, "results": self.$results()});
        };

        def.$to_json = function() {
          var self = this;

          return $scope.get('JSON').$pretty_generate(self.$to_hash());
        };

        return (def.$filename = function() {
          var $a, $b, TMP_3, self = this, timestamp = nil, time = nil, player1 = nil, player2 = nil;

          timestamp = (function() {try {return ($a = ($b = self.$turns()).$detect, $a.$$p = (TMP_3 = function(t){var self = TMP_3.$$s || this;
if (t == null) t = nil;
          return t.$timestamp()['$=='](nil)['$!']()}, TMP_3.$$s = self, TMP_3), $a).call($b).$timestamp() } catch ($err) { return $scope.get('Time').$now().$to_i() }})();
          time = $scope.get('Time').$at(timestamp).$strftime("%Y%m%d_%H%M%S");
          player1 = self.$players().$first().$name();
          player2 = self.$players().$last().$name();
          return "" + (time) + "_" + (self.$mode()) + "_" + (player1) + "_vs_" + (player2);
        }, nil) && 'filename';
      })(self, null)
    })(self)
  })(self);
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/data"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  return self.$require("hearthstone/log/data"+ '/../' + "./data/game")
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/game_logger"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$attr_accessor', '$new', '$each_line', '$log_line', '$parse_line', '$parser', '$[]', '$debug', '$process_event', '$private', '$===', '$on_game_over', '$on_turn_start', '$on_turn', '$on_game_mode', '$on_player_id', '$on_first_player', '$on_set_hero', '$on_set_hero_power', '$on_hero_destroyed', '$on_event', '$mode=', '$game=', '$respond_to?', '$delegate', '$player_with_id_or_name', '$game', '$name=', '$id=', '$first_player=', '$hero=', '$hero_power=', '$[]=', '$results', '$completed?', '$==', '$count', '$mode', '$player=', '$current_turn', '$timestamp=', '$add_turn', '$add_event']);
  self.$require("hearthstone/log/game_logger"+ '/../' + "./parser");
  self.$require("hearthstone/log/game_logger"+ '/../' + "./data");
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $GameLogger(){};
        var self = $GameLogger = $klass($base, $super, 'GameLogger', $GameLogger);

        var def = self.$$proto, $scope = self.$$scope;

        self.$attr_reader("parser", "debug");

        self.$attr_accessor("game", "delegate", "mode");

        def.$initialize = function(delegate, $kwargs) {
          var self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((debug = $kwargs.smap['debug']) == null) {
            debug = false
          }
          self.delegate = delegate;
          self.parser = $scope.get('Parser').$new();
          self.game = $scope.get('Game').$new(nil);
          self.debug = debug;
          return self.mode = nil;
        };

        def.$log_file = function(io) {
          var $a, $b, TMP_1, self = this;

          return ($a = ($b = io).$each_line, $a.$$p = (TMP_1 = function(line){var self = TMP_1.$$s || this;
if (line == null) line = nil;
          return self.$log_line(line)}, TMP_1.$$s = self, TMP_1), $a).call($b);
        };

        def.$log_line = function(line) {
          var $a, self = this, result = nil, name = nil, data = nil, log_line = nil;

          result = self.$parser().$parse_line(line);
          if (result !== false && result !== nil) {
            name = result['$[]'](0);
            data = result['$[]'](1);
            if ((($a = self.$debug()) !== nil && (!$a.$$is_boolean || $a == true))) {
              log_line = line};
            return self.$process_event(name, data, log_line);
            } else {
            return nil
          };
        };

        self.$private();

        def.$process_event = function(event, data, line) {
          var self = this, $case = nil;

          if (line == null) {
            line = nil
          }
          return (function() {$case = event;if ("game_start"['$===']($case)) {return nil}else if ("game_over"['$===']($case)) {return self.$on_game_over(data)}else if ("turn_start"['$===']($case)) {return self.$on_turn_start(data)}else if ("turn"['$===']($case)) {return self.$on_turn(data)}else if ("begin_spectator_mode"['$===']($case) || "end_spectator_mode"['$===']($case)) {return nil}else if ("mode"['$===']($case)) {return self.$on_game_mode(data)}else if ("player_id"['$===']($case)) {return self.$on_player_id(data)}else if ("first_player"['$===']($case)) {return self.$on_first_player(data)}else if ("attack"['$===']($case) || "attacked"['$===']($case)) {return nil}else if ("set_hero"['$===']($case)) {return self.$on_set_hero(data)}else if ("set_hero_power"['$===']($case)) {return self.$on_set_hero_power(data)}else if ("hero_destroyed"['$===']($case)) {return self.$on_hero_destroyed(data)}else {if (event !== false && event !== nil) {
            return self.$on_event(event, data, line)
            } else {
            return nil
          }}})();
        };

        def.$on_game_mode = function(mode) {
          var $a, $b, self = this;

          (($a = [mode]), $b = self, $b['$mode='].apply($b, $a), $a[$a.length-1]);
          (($a = [$scope.get('Game').$new(mode)]), $b = self, $b['$game='].apply($b, $a), $a[$a.length-1]);
          if ((($a = self.$delegate()['$respond_to?']("on_game_mode")) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$delegate().$on_game_mode(mode)
            } else {
            return nil
          };
        };

        def.$on_player_id = function($kwargs) {
          var $a, $b, self = this, player = nil;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          if ((player_id = $kwargs.smap['player_id']) == null) {
            player_id = nil
          }
          player = self.$game().$player_with_id_or_name($hash2(["name", "id"], {"name": name, "id": player_id}));
          (($a = [name]), $b = player, $b['$name='].apply($b, $a), $a[$a.length-1]);
          return (($a = [player_id]), $b = player, $b['$id='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_first_player = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          return (($a = [true]), $b = self.$game().$player_with_id_or_name($hash2(["name"], {"name": name})), $b['$first_player='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_set_hero = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((player_id = $kwargs.smap['player_id']) == null) {
            player_id = nil
          }
          if ((id = $kwargs.smap['id']) == null) {
            id = nil
          }
          if ((card_id = $kwargs.smap['card_id']) == null) {
            card_id = nil
          }
          if ((zone_pos = $kwargs.smap['zone_pos']) == null) {
            zone_pos = 0
          }
          return (($a = [$hash2(["id", "card_id"], {"id": id, "card_id": card_id})]), $b = self.$game().$player_with_id_or_name($hash2(["id"], {"id": player_id})), $b['$hero='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_set_hero_power = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((player_id = $kwargs.smap['player_id']) == null) {
            player_id = nil
          }
          if ((id = $kwargs.smap['id']) == null) {
            id = nil
          }
          if ((card_id = $kwargs.smap['card_id']) == null) {
            card_id = nil
          }
          if ((zone_pos = $kwargs.smap['zone_pos']) == null) {
            zone_pos = 0
          }
          return (($a = [$hash2(["id", "card_id"], {"id": id, "card_id": card_id})]), $b = self.$game().$player_with_id_or_name($hash2(["id"], {"id": player_id})), $b['$hero_power='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_game_over = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          if ((state = $kwargs.smap['state']) == null) {
            state = nil
          }
          self.$game().$results()['$[]='](name, state);
          if ((($a = self.$delegate()['$respond_to?']("on_game_over")) !== nil && (!$a.$$is_boolean || $a == true))) {
            if ((($a = ($b = self.$game()['$completed?'](), $b !== false && $b !== nil ?self.$game().$results().$count()['$=='](2) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
              return self.$delegate().$on_game_over(self.$game())
              } else {
              return nil
            }
            } else {
            return nil
          };
        };

        def.$on_hero_destroyed = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((player_id = $kwargs.smap['player_id']) == null) {
            player_id = nil
          }
          if ((id = $kwargs.smap['id']) == null) {
            id = nil
          }
          if ((card_id = $kwargs.smap['card_id']) == null) {
            card_id = nil
          }
          if ((zone_pos = $kwargs.smap['zone_pos']) == null) {
            zone_pos = 0
          }
          return (($a = [$scope.get('Game').$new(self.$mode())]), $b = self, $b['$game='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_turn_start = function($kwargs) {
          var $a, $b, self = this;

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          }
          if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expecting keyword args');
          }
          if ((name = $kwargs.smap['name']) == null) {
            name = nil
          }
          if ((timestamp = $kwargs.smap['timestamp']) == null) {
            timestamp = nil
          }
          (($a = [name]), $b = self.$game().$current_turn(), $b['$player='].apply($b, $a), $a[$a.length-1]);
          return (($a = [timestamp]), $b = self.$game().$current_turn(), $b['$timestamp='].apply($b, $a), $a[$a.length-1]);
        };

        def.$on_turn = function(turn) {
          var self = this;

          return self.$game().$add_turn($hash2(["number"], {"number": turn}));
        };

        return (def.$on_event = function(event, data, line) {
          var $a, self = this;

          if (line == null) {
            line = nil
          }
          self.$game().$current_turn().$add_event(event, data, line);
          if ((($a = self.$delegate()['$respond_to?']("on_event")) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$delegate().$on_event(event, data)
            } else {
            return nil
          };
        }, nil) && 'on_event';
      })(self, null)
    })(self)
  })(self);
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log/configurator"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$attr_reader', '$exists?', '$path', '$read', '$!', '$=~', '$open', '$write']);
  return (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $Configurator(){};
        var self = $Configurator = $klass($base, $super, 'Configurator', $Configurator);

        var def = self.$$proto, $scope = self.$$scope;

        self.$attr_reader("path");

        def.$initialize = function(path) {
          var self = this;

          if (path == null) {
            path = "~/Library/Preferences/Blizzard/Hearthstone/log.config"
          }
          return self.path = path;
        };

        def['$needs_config?'] = function() {
          var $a, self = this, data = nil;

          if ((($a = $scope.get('File')['$exists?'](self.$path())) !== nil && (!$a.$$is_boolean || $a == true))) {
            } else {
            return true
          };
          data = $scope.get('File').$read(self.$path());
          return (($a = data['$=~'](/\[Zone\]/), $a !== false && $a !== nil ?data['$=~'](/\[Power\]/) : $a))['$!']();
        };

        return (def.$configure = function() {
          var $a, $b, TMP_1, self = this, config = nil, mode = nil;

          config = "[Zone]\nLogLevel=1\nFilePrinting=false\nConsolePrinting=true\nScreenPrinting=false\n\n[Power]\nLogLevel=1\nConsolePrinting=true\n";
          mode = "w";
          if ((($a = $scope.get('File')['$exists?'](self.$path())) !== nil && (!$a.$$is_boolean || $a == true))) {
            mode = "a"};
          return ($a = ($b = $scope.get('File')).$open, $a.$$p = (TMP_1 = function(f){var self = TMP_1.$$s || this;
if (f == null) f = nil;
          return f.$write(config)}, TMP_1.$$s = self, TMP_1), $a).call($b, self.$path(), mode);
        }, nil) && 'configure';
      })(self, null)
    })(self)
  })(self)
};

/* Generated by Opal 0.7.0.beta4 */
Opal.modules["hearthstone/log"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Log');

      var def = self.$$proto, $scope = self.$$scope;

      nil
    })(self)
  })(self);
  self.$require("hearthstone/log"+ '/../' + "./log/game_logger");
  return self.$require("hearthstone/log"+ '/../' + "./log/configurator");
};

/* Generated by Opal 0.7.0.beta4 */
(function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  self.$require("hearthstone"+ '/../' + "./hearthstone/version");
  (function($base) {
    var self = $module($base, 'Hearthstone');

    var def = self.$$proto, $scope = self.$$scope;

    nil
  })(self);
  return self.$require("hearthstone"+ '/../' + "./hearthstone/log");
})(Opal);

//# sourceMappingURL=hearthstone.map
;
